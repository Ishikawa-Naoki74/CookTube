import { PrismaClient, JobStatus } from '@prisma/client';
import { YouTubeService } from './youtube';
import { AWSTranscribeService } from './aws-transcribe';
import { AWSRekognitionService } from './aws-rekognition';
import { AWSRekognitionVideoService } from './aws-rekognition-video';
import { VideoProcessor } from './video-processor';
import { AWSBedrockService } from './aws-bedrock';
import { YouTubeProcessor } from './youtube-processor';
import { FrameAnalyzer } from './frame-analyzer';

export interface ProcessingJobUpdate {
  jobId: string;
  status: JobStatus;
  progressPercent: number;
  errorMessage?: string;
}

export type ProcessingProgressCallback = (update: ProcessingJobUpdate) => void;

export class RecipeProcessorService {
  private prisma: PrismaClient;
  private youtubeService: YouTubeService;
  private transcribeService: AWSTranscribeService;
  private rekognitionService: AWSRekognitionService;
  private rekognitionVideoService: AWSRekognitionVideoService;
  private videoProcessor: VideoProcessor;
  private bedrockService: AWSBedrockService;
  private youtubeProcessor: YouTubeProcessor;
  private frameAnalyzer: FrameAnalyzer;

  constructor() {
    console.log('üèóÔ∏è  Initializing RecipeProcessorService');
    this.prisma = new PrismaClient();
    this.youtubeService = new YouTubeService();
    this.transcribeService = new AWSTranscribeService();
    this.rekognitionService = new AWSRekognitionService();
    this.rekognitionVideoService = new AWSRekognitionVideoService();
    this.videoProcessor = new VideoProcessor();
    this.bedrockService = new AWSBedrockService();
    this.youtubeProcessor = new YouTubeProcessor();
    this.frameAnalyzer = new FrameAnalyzer();
    console.log('‚úÖ RecipeProcessorService initialized');
  }

  async startProcessing(
    userId: string,
    youtubeUrl: string,
    progressCallback?: ProcessingProgressCallback
  ): Promise<string> {
    // Validate YouTube URL
    if (!YouTubeService.validateYouTubeUrl(youtubeUrl)) {
      throw new Error('Invalid YouTube URL');
    }

    // Create processing job
    const job = await this.prisma.processingJob.create({
      data: {
        userId,
        youtubeUrl,
        status: 'pending',
        progressPercent: 0,
      },
    });

    // Process asynchronously
    this.processVideo(job.id, userId, youtubeUrl, progressCallback).catch(error => {
      console.error('Background processing failed:', error);
      this.updateJobStatus(job.id, 'failed', 0, error.message, progressCallback);
    });

    return job.id;
  }

  private async updateJobStatus(
    jobId: string,
    status: JobStatus,
    progressPercent: number,
    errorMessage?: string,
    progressCallback?: ProcessingProgressCallback
  ): Promise<void> {
    await this.prisma.processingJob.update({
      where: { id: jobId },
      data: {
        status,
        progressPercent,
        errorMessage,
      },
    });

    if (progressCallback) {
      progressCallback({
        jobId,
        status,
        progressPercent,
        errorMessage,
      });
    }
  }

  private async processVideo(
    jobId: string,
    userId: string,
    youtubeUrl: string,
    progressCallback?: ProcessingProgressCallback
  ): Promise<void> {
    let videoData: any = null;
    let videoInfo: any = null;

    try {
      // Step 1: Get video information from YouTube API
      await this.updateJobStatus(jobId, 'pending', 5, undefined, progressCallback);
      
      console.log('üé¨ Fetching video info for:', youtubeUrl);
      videoInfo = await YouTubeService.getVideoInfo(youtubeUrl);
      console.log('‚úÖ Video info retrieved:', {
        id: videoInfo.id,
        title: videoInfo.title,
        duration: videoInfo.duration,
        uploader: videoInfo.uploader
      });

      await this.updateJobStatus(jobId, 'pending', 10, undefined, progressCallback);

      // Step 2: Process video with yt-dlp (transcript + audio + frames)
      console.log('üì• Processing video with yt-dlp...');
      try {
        videoData = await this.youtubeProcessor.processVideo(youtubeUrl, videoInfo.id);
        console.log('‚úÖ Video processing completed');
      } catch (error) {
        console.error('Video processing error:', error);
        // Continue with just basic video info
      }

      await this.updateJobStatus(jobId, 'transcribing', 25, undefined, progressCallback);

      // Step 3: Enhanced Transcription - Use YouTube transcript or AWS Transcribe with fallbacks
      let transcriptionText = '';
      
      if (videoData?.transcript && videoData.transcript.length > 100) {
        console.log('‚úÖ Using YouTube transcript (length:', videoData.transcript.length, ')');
        transcriptionText = videoData.transcript;
      } else {
        console.log('üîÑ YouTube transcript insufficient, using AWS Transcribe...');
        if (videoData?.audioPath) {
          try {
            console.log('üéôÔ∏è Starting AWS Transcribe for detailed audio analysis...');
            const transcriptionResult = await this.transcribeService.transcribeAudio(videoData.audioPath, videoInfo.id);
            transcriptionText = transcriptionResult.text;
            console.log('‚úÖ AWS Transcription completed, length:', transcriptionText.length);
            
            // Combine with YouTube transcript if available for better accuracy
            if (videoData?.transcript && videoData.transcript.length > 0) {
              transcriptionText = `${videoData.transcript}\n\n[AWSË£úÂÆåÈü≥Â£∞Ëß£Êûê]\n${transcriptionText}`;
              console.log('‚úÖ Combined YouTube transcript with AWS Transcribe result');
            }
          } catch (error) {
            console.error('AWS Transcription error:', error);
            if (videoData?.transcript) {
              transcriptionText = videoData.transcript;
              console.log('‚ö†Ô∏è Falling back to available YouTube transcript');
            }
          }
        } else if (videoData?.transcript) {
          transcriptionText = videoData.transcript;
          console.log('‚ö†Ô∏è Using available YouTube transcript (audio download failed)');
        }
      }

      await this.updateJobStatus(jobId, 'recognizing', 50, undefined, progressCallback);

      // Step 4: Image and Video recognition using AWS Rekognition
      let recognitionLabels: string[] = [];
      let videoAnalysisResult: any = null;
      
      // 4a. Static frame analysis
      if (videoData?.thumbnailFrames && videoData.thumbnailFrames.length > 0) {
        try {
          console.log('üëÅÔ∏è Starting AWS Rekognition for frames...');
          for (const framePath of videoData.thumbnailFrames) {
            const labels = await this.rekognitionService.detectLabels(framePath);
            recognitionLabels.push(...labels.map((l: any) => l.name));
          }
          console.log('‚úÖ Frame recognition completed:', recognitionLabels.length, 'labels found');
        } catch (error) {
          console.error('AWS Recognition error:', error);
        }
      }

      // 4b. Video analysis if video is uploaded to S3
      if (videoData?.videoS3Url) {
        try {
          console.log('üé¨ Starting AWS Rekognition Video analysis...');
          const s3Uri = videoData.videoS3Url.replace('https://', 's3://').replace('.s3.ap-northeast-1.amazonaws.com', '');
          const jobId = await this.rekognitionVideoService.startVideoLabelDetection(s3Uri);
          console.log('‚è≥ Video analysis job started:', jobId);
          
          // Wait for analysis to complete (with timeout)
          await this.rekognitionVideoService.waitForJobCompletion(jobId, 60000); // 1 minute timeout
          
          // Get analysis results
          videoAnalysisResult = await this.rekognitionVideoService.getVideoAnalysisResults(jobId);
          
          // Add video-detected ingredients to recognition labels
          for (const ingredient of videoAnalysisResult.ingredients) {
            recognitionLabels.push(ingredient);
          }
          
          console.log('‚úÖ Video analysis completed:', {
            ingredients: videoAnalysisResult.ingredients.size,
            tools: videoAnalysisResult.cookingTools.size,
            actions: videoAnalysisResult.cookingActions.length,
          });
        } catch (error) {
          console.error('AWS Rekognition Video error:', error);
        }
      }

      // Step 4c: Enhanced frame analysis for Shorts videos
      let frameAnalysisResult: any = null;
      if (videoData?.frameS3Urls && videoData.frameS3Urls.length > 0) {
        try {
          console.log('üî¨ Starting enhanced frame analysis...');
          const isShortVideo = this.isShortVideo(videoInfo);
          
          // Process a few key frames with detailed analysis
          const keyFrames = videoData.frameS3Urls.slice(0, 5); // Analyze first 5 frames
          let allIngredients: any[] = [];
          let allTools: any[] = [];
          let allActions: any[] = [];
          
          for (const frameUrl of keyFrames) {
            try {
              const frameBuffer = await this.downloadFrameFromS3(frameUrl);
              const analysisResult = await this.frameAnalyzer.analyzeFrame(frameBuffer, isShortVideo);
              
              allIngredients.push(...analysisResult.ingredients);
              allTools.push(...analysisResult.tools);
              allActions.push(...analysisResult.actions);
            } catch (frameError) {
              console.error(`Frame analysis error for ${frameUrl}:`, frameError);
            }
          }
          
          // Deduplicate and sort by confidence
          frameAnalysisResult = {
            ingredients: this.deduplicateByName(allIngredients).sort((a: any, b: any) => b.confidence - a.confidence),
            tools: this.deduplicateByName(allTools).sort((a: any, b: any) => b.confidence - a.confidence),
            actions: this.deduplicateByName(allActions, 'action').sort((a: any, b: any) => b.confidence - a.confidence)
          };
          
          console.log(`‚úÖ Enhanced frame analysis completed: ${frameAnalysisResult.ingredients.length} ingredients, ${frameAnalysisResult.tools.length} tools, ${frameAnalysisResult.actions.length} actions`);
        } catch (error) {
          console.error('Enhanced frame analysis error:', error);
        }
      }

      await this.updateJobStatus(jobId, 'generating', 75, undefined, progressCallback);

      // Step 5: Generate recipe using AWS Bedrock
      console.log('ü§ñ Generating recipe with AWS Bedrock...');
      
      // Step 5a: Integrate audio and visual analysis
      let integratedAnalysis: any = null;
      if (transcriptionText && frameAnalysisResult) {
        try {
          console.log('üîó Integrating audio and visual analysis...');
          integratedAnalysis = this.integrateAudioVisualAnalysis(
            transcriptionText,
            frameAnalysisResult,
            recognitionLabels
          );
          console.log(`‚úÖ Audio-visual integration completed with ${integratedAnalysis.confidence}% confidence`);
        } catch (error) {
          console.error('Integration error:', error);
        }
      }

      let generatedRecipe;
      try {
        const prompt = this.createRecipePrompt(
          videoInfo,
          transcriptionText,
          [...new Set(recognitionLabels)], // Remove duplicates
          frameAnalysisResult,
          integratedAnalysis
        );

        generatedRecipe = await this.bedrockService.generateRecipe(prompt);
        console.log('‚úÖ AWS Bedrock recipe generated');
      } catch (aiError) {
        console.error('AWS Bedrock error, using fallback:', aiError);
        // Use enhanced fallback based on available data
        generatedRecipe = this.generateMockRecipe(
          videoInfo.title || 'Recipe',
          videoInfo.description || transcriptionText || 'Generated recipe'
        );
        console.log('‚úÖ Enhanced fallback recipe generated');
      }

      await this.updateJobStatus(jobId, 'generating', 95, undefined, progressCallback);

      // Step 6: Save recipe to Supabase
      console.log('üíæ Saving recipe to Supabase...');
      const recipe = await this.prisma.recipe.create({
        data: {
          userId,
          youtubeUrl,
          videoTitle: videoInfo.title,
          videoThumbnail: videoInfo.thumbnail,
          ingredients: generatedRecipe.ingredients || [],
          steps: generatedRecipe.steps || [],
          transcriptionText: transcriptionText || '',
          recognitionLabels: [...new Set(recognitionLabels)],
          audioS3Url: videoData?.audioS3Url || null,
          videoS3Url: videoData?.videoS3Url || null,
          frameS3Urls: videoData?.frameS3Urls || null,
        },
      });

      // Step 7: Complete job
      await this.updateJobStatus(jobId, 'completed', 100, undefined, progressCallback);

      console.log('‚úÖ Recipe processing completed and saved to Supabase:', recipe.id);

    } catch (error) {
      console.error('Error processing video:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      await this.updateJobStatus(jobId, 'failed', 0, errorMessage, progressCallback);
      throw error;
    } finally {
      // Cleanup temporary files
      if (videoData?.id || videoInfo?.id) {
        await this.youtubeProcessor.cleanup(videoData?.id || videoInfo?.id);
      }
    }
  }

  private generateMockRecipe(title: string, description: string): any {
    // Extract common cooking terms and ingredients from title/description
    const text = (title + ' ' + description).toLowerCase();
    
    const ingredients = [];
    const steps = [];
    
    // Common ingredients detection
    const commonIngredients = [
      { pattern: /chicken|È∂è|„Å®„Çä/i, item: { name: 'È∂èËÇâ', amount: '300', unit: 'g' } },
      { pattern: /beef|Áâõ|„Éì„Éº„Éï/i, item: { name: 'ÁâõËÇâ', amount: '300', unit: 'g' } },
      { pattern: /pork|Ë±ö|„Éù„Éº„ÇØ/i, item: { name: 'Ë±öËÇâ', amount: '300', unit: 'g' } },
      { pattern: /rice|„ÅîÈ£Ø|Á±≥/i, item: { name: '„ÅîÈ£Ø', amount: '2', unit: 'Âêà' } },
      { pattern: /onion|Áéâ„Å≠„Åé|„Åü„Åæ„Å≠„Åé/i, item: { name: 'Áéâ„Å≠„Åé', amount: '1', unit: 'ÂÄã' } },
      { pattern: /carrot|‰∫∫ÂèÇ|„Å´„Çì„Åò„Çì/i, item: { name: '‰∫∫ÂèÇ', amount: '1', unit: 'Êú¨' } },
      { pattern: /potato|„Åò„ÇÉ„Åå„ÅÑ„ÇÇ|„Éù„ÉÜ„Éà/i, item: { name: '„Åò„ÇÉ„Åå„ÅÑ„ÇÇ', amount: '2', unit: 'ÂÄã' } },
      { pattern: /egg|Âçµ|„Åü„Åæ„Åî/i, item: { name: 'Âçµ', amount: '2', unit: 'ÂÄã' } },
      { pattern: /salt|Â°©/i, item: { name: 'Â°©', amount: 'ÈÅ©Èáè', unit: '' } },
      { pattern: /pepper|ËÉ°Ê§í|„Åì„Åó„Çá„ÅÜ/i, item: { name: 'ËÉ°Ê§í', amount: 'ÈÅ©Èáè', unit: '' } },
      { pattern: /oil|Ê≤π|„Ç™„Ç§„É´/i, item: { name: '„Çµ„É©„ÉÄÊ≤π', amount: 'Â§ß„Åï„Åò2', unit: '' } },
      { pattern: /soy sauce|ÈÜ§Ê≤π|„Åó„Çá„ÅÜ„ÇÜ/i, item: { name: 'ÈÜ§Ê≤π', amount: 'Â§ß„Åï„Åò2', unit: '' } },
    ];
    
    // Add ingredients found in title/description
    for (const { pattern, item } of commonIngredients) {
      if (pattern.test(text)) {
        ingredients.push(item);
      }
    }
    
    // If no ingredients found, add some defaults based on title
    if (ingredients.length === 0) {
      ingredients.push(
        { name: '„É°„Ç§„É≥È£üÊùê', amount: '300', unit: 'g' },
        { name: 'Ë™øÂë≥Êñô', amount: 'ÈÅ©Èáè', unit: '' }
      );
    }
    
    // Generate basic steps based on common cooking methods
    if (/fry|ÁÇí|ÁÑº/i.test(text)) {
      steps.push(
        { step_number: 1, description: 'ÊùêÊñô„ÇíÈ£ü„Åπ„ÇÑ„Åô„ÅÑÂ§ß„Åç„Åï„Å´Âàá„Çã', timestamp: 0 },
        { step_number: 2, description: '„Éï„É©„Ç§„Éë„É≥„Å´Ê≤π„ÇíÁÜ±„Åô„Çã', timestamp: 0 },
        { step_number: 3, description: 'ÊùêÊñô„ÇíÁÇí„ÇÅ„Çã', timestamp: 0 },
        { step_number: 4, description: 'Ë™øÂë≥Êñô„ÅßÂë≥„ÇíË™ø„Åà„Çã', timestamp: 0 },
        { step_number: 5, description: 'ÂÆåÊàê', timestamp: 0 }
      );
    } else if (/boil|ÁÖÆ|Ëåπ/i.test(text)) {
      steps.push(
        { step_number: 1, description: 'ÊùêÊñô„ÇíÊ∫ñÂÇô„Åô„Çã', timestamp: 0 },
        { step_number: 2, description: 'Èçã„Å´Ê∞¥„ÇíÂÖ•„Çå„Å¶Ê≤∏È®∞„Åï„Åõ„Çã', timestamp: 0 },
        { step_number: 3, description: 'ÊùêÊñô„ÇíÂÖ•„Çå„Å¶ÁÖÆ„Çã', timestamp: 0 },
        { step_number: 4, description: 'Âë≥„ÇíË™ø„Åà„Çã', timestamp: 0 },
        { step_number: 5, description: 'ÂÆåÊàê', timestamp: 0 }
      );
    } else if (/bake|„Ç™„Éº„Éñ„É≥|ÁÑº„Åç/i.test(text)) {
      steps.push(
        { step_number: 1, description: '„Ç™„Éº„Éñ„É≥„Çí180‚ÑÉ„Å´‰∫àÁÜ±„Åô„Çã', timestamp: 0 },
        { step_number: 2, description: 'ÊùêÊñô„ÇíÊ∫ñÂÇô„Åô„Çã', timestamp: 0 },
        { step_number: 3, description: 'Â§©Êùø„Å´‰∏¶„Åπ„Çã', timestamp: 0 },
        { step_number: 4, description: '„Ç™„Éº„Éñ„É≥„Åß20ÂàÜÁÑº„Åè', timestamp: 0 },
        { step_number: 5, description: 'ÂÆåÊàê', timestamp: 0 }
      );
    } else {
      // Default steps
      steps.push(
        { step_number: 1, description: 'ÊùêÊñô„ÇíÊ∫ñÂÇô„Åô„Çã', timestamp: 0 },
        { step_number: 2, description: '‰∏ã„Åî„Åó„Çâ„Åà„Çí„Åô„Çã', timestamp: 0 },
        { step_number: 3, description: 'Ë™øÁêÜ„Åô„Çã', timestamp: 0 },
        { step_number: 4, description: 'Áõõ„Çä‰ªò„Åë„Çã', timestamp: 0 },
        { step_number: 5, description: 'ÂÆåÊàê', timestamp: 0 }
      );
    }
    
    return {
      ingredients,
      steps
    };
  }

  private createRecipePrompt(
    videoInfo: any,
    transcription: string,
    labels: string[],
    frameAnalysisResult?: any,
    integratedAnalysis?: any
  ): string {
    // „Ç∑„Éß„Éº„ÉàÂãïÁîª„Åã„Å©„ÅÜ„Åã„ÇíÂà§ÂÆö
    const isShortVideo = this.isShortVideo(videoInfo);
    
    if (isShortVideo) {
      return this.createShortsRecipePrompt(videoInfo, transcription, labels, frameAnalysisResult, integratedAnalysis);
    } else {
      return this.createRegularRecipePrompt(videoInfo, transcription, labels, frameAnalysisResult, integratedAnalysis);
    }
  }

  private isShortVideo(videoInfo: any): boolean {
    const url = videoInfo?.youtubeUrl || '';
    const duration = parseInt(videoInfo?.duration) || 0;
    
    return url.includes('/shorts/') || url.includes('youtube.com/shorts') || duration <= 60;
  }

  private createShortsRecipePrompt(
    videoInfo: any,
    transcription: string,
    labels: string[],
    frameAnalysisResult?: any,
    integratedAnalysis?: any
  ): string {
    const ingredients = frameAnalysisResult?.ingredients || [];
    const tools = frameAnalysisResult?.tools || [];
    const actions = frameAnalysisResult?.actions || [];

    return `
„ÅÇ„Å™„Åü„ÅØÁü≠ÊôÇÈñìÂãïÁîª„É¨„Ç∑„ÉîËß£Êûê„ÅÆ„Éó„É≠„Éï„Çß„ÉÉ„Ç∑„Éß„Éä„É´„Åß„Åô„ÄÇYouTube ShortsÂãïÁîªÔºà60Áßí‰ª•‰∏ãÔºâ„ÅÆÊÉÖÂ†±„Åã„Çâ„ÄÅÂÆüË∑µÁöÑ„Å™„É¨„Ç∑„Éî„ÇíÊäΩÂá∫„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

‚ö†Ô∏è SHORTSÂãïÁîª„ÅÆÁâπÂæ¥„ÇíËÄÉÊÖÆ„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö
- Áü≠ÊôÇÈñì„ÅßÂÆåÁµê„Åô„ÇãÁ∞°Âçò„Å™„É¨„Ç∑„Éî
- Âü∫Êú¨ÁöÑ„Å™È£üÊùê„Å®Ë™øÁêÜÊ≥ï
- Ë¶ñË¶öÁöÑ„Å´„Çè„Åã„Çä„ÇÑ„Åô„ÅÑÊâãÈ†Ü
- ‰∏Ä„Å§„ÅÆ„É°„Ç§„É≥ÊñôÁêÜ„Å´ÈõÜ‰∏≠

„ÄêÂãïÁîªÊÉÖÂ†±„Äë
„Çø„Ç§„Éà„É´: ${videoInfo.title}
ÊôÇÈñì: ${videoInfo.duration}ÁßíÔºà„Ç∑„Éß„Éº„ÉàÂãïÁîªÔºâ

„ÄêÈü≥Â£∞Ëª¢ÂÜôÂÜÖÂÆπ„Äë:
${transcription || 'Èü≥Â£∞Ëª¢ÂÜô„Å™„Åó'}

„ÄêË©≥Á¥∞„Éï„É¨„Éº„É†ÂàÜÊûêÁµêÊûú„Äë:
Ê§úÂá∫È£üÊùê: ${ingredients.map((i: any) => `${i.name}(‰ø°È†ºÂ∫¶:${i.confidence}%)`).join(', ') || 'Ê§úÂá∫„Å™„Åó'}
Ê§úÂá∫Ë™øÁêÜÂô®ÂÖ∑: ${tools.map((t: any) => `${t.name}(‰ø°È†ºÂ∫¶:${t.confidence}%)`).join(', ') || 'Ê§úÂá∫„Å™„Åó'}
Êé®Ë´ñ„Åï„Çå„ÅüË™øÁêÜÂãï‰Ωú: ${actions.map((a: any) => `${a.action}(‰ø°È†ºÂ∫¶:${a.confidence}%)`).join(', ') || 'Ê§úÂá∫„Å™„Åó'}

„ÄêÂü∫Êú¨„É©„Éô„É´„Äë: ${labels.join(', ') || 'Ê§úÂá∫È†ÖÁõÆ„Å™„Åó'}

${integratedAnalysis ? `
„ÄêÁµ±ÂêàÂàÜÊûêÁµêÊûú„Äë(‰ø°È†ºÂ∫¶:${integratedAnalysis.confidence}%):
Èü≥Â£∞„Åã„ÇâÊ§úÂá∫„Åï„Çå„ÅüÈ£üÊùê: ${integratedAnalysis.audioKeywords.ingredients.join(', ') || '„Å™„Åó'}
Èü≥Â£∞„Åã„ÇâÊ§úÂá∫„Åï„Çå„ÅüÂãï‰Ωú: ${integratedAnalysis.audioKeywords.actions.join(', ') || '„Å™„Åó'}
Áµ±ÂêàÈ£üÊùê„É™„Çπ„Éà: ${integratedAnalysis.ingredients.map((i: any) => `${i.name}(${i.source})`).join(', ') || '„Å™„Åó'}
Áµ±ÂêàÊâãÈ†Ü: ${integratedAnalysis.steps.map((s: any) => `${s.description}(${s.source})`).join(' ‚Üí ') || '„Å™„Åó'}
` : ''}

üî• SHORTSÂ∞ÇÁî®ÊåáÁ§∫:
1. ÊùêÊñô„ÅØ5ÂÄã‰ª•ÂÜÖ„ÅÆÁ∞°Âçò„Å™„ÇÇ„ÅÆ
2. ÊâãÈ†Ü„ÅØ3-5„Çπ„ÉÜ„ÉÉ„Éó„Å´Áµû„Çã
3. ÂêÑ„Çπ„ÉÜ„ÉÉ„Éó„ÅØ30Áßí‰ª•ÂÜÖ„ÅßÂÆå‰∫Ü„Åß„Åç„Çã„ÇÇ„ÅÆ
4. Â∞ÇÈñÄÁî®Ë™û„ÇíÈÅø„Åë„ÄÅÂàùÂøÉËÄÖ„Åß„ÇÇÁêÜËß£„Åß„Åç„ÇãË°®Áèæ
5. ÊôÇÈñì„ÇÑÂàÜÈáè„ÅØ„ÄåÂ∞ë„ÄÖ„Äç„ÄåÈÅ©Èáè„Äç„Çà„ÇäÂÖ∑‰ΩìÁöÑ„Å´

‰ª•‰∏ã„ÅÆJSONÂΩ¢Âºè„ÅßÁîüÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö

{
  "ingredients": [
    { 
      "name": "È£üÊùêÂêç", 
      "amount": "ÂàÜÈáè", 
      "unit": "Âçò‰Ωç",
      "notes": "Á∞°Âçò„Å™Ë™¨Êòé"
    }
  ],
  "steps": [
    { 
      "step_number": 1, 
      "description": "Á∞°ÊΩî„ÅßÂÖ∑‰ΩìÁöÑ„Å™ÊâãÈ†ÜÔºàÊôÇÈñì„ÉªÁÅ´Âä†Ê∏õËæº„ÅøÔºâ", 
      "duration": "ÊôÇÈñì",
      "tips": "Â§±Êïó„Åó„Å™„ÅÑ„Ç≥„ÉÑ"
    }
  ]
}`;
  }

  private createRegularRecipePrompt(
    videoInfo: any,
    transcription: string,
    labels: string[],
    frameAnalysisResult?: any,
    integratedAnalysis?: any
  ): string {
    return `
„ÅÇ„Å™„Åü„ÅØÁµåÈ®ìË±äÂØå„Å™ÊñôÁêÜÁ†îÁ©∂ÂÆ∂„Åß„ÅÇ„Çä„ÄÅYouTubeÊñôÁêÜÂãïÁîª„ÅÆË©≥Á¥∞ÂàÜÊûê„ÅÆ„Çπ„Éö„Ç∑„É£„É™„Çπ„Éà„Åß„Åô„ÄÇ‰ª•‰∏ã„ÅÆÊÉÖÂ†±„Åã„Çâ„ÄÅÂÆüÈöõ„Å´ÊñôÁêÜ„Åß„Åç„ÇãÂÆåÂÖ®„Å™„É¨„Ç∑„Éî„ÇíË©≥Á¥∞„Å´ÊäΩÂá∫„ÉªÊßãÁØâ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

„ÄêÂãïÁîªÊÉÖÂ†±„Äë
„Çø„Ç§„Éà„É´: ${videoInfo.title}
Ë™¨Êòé: ${videoInfo.description}

„ÄêÈü≥Â£∞Ëª¢ÂÜôÂÜÖÂÆπÔºàÂãïÁîªÂÖ®‰Ωì„ÅßË©±„Åï„Çå„ÅüÂÖ®„Å¶„ÅÆÂÜÖÂÆπÔºâ„Äë:
${transcription || 'Èü≥Â£∞Ëª¢ÂÜô„Å™„Åó'}

„ÄêÂãïÁîª„Åã„ÇâÊ§úÂá∫„Åï„Çå„ÅüÈ£üÊùê„ÉªÂô®ÂÖ∑Ôºà15„Éï„É¨„Éº„É†ÂàÜÊûêÁµêÊûúÔºâ„Äë:
${labels.join(', ') || 'Ê§úÂá∫È†ÖÁõÆ„Å™„Åó'}

‰ª•‰∏ã„ÅÆJSONÂΩ¢Âºè„ÅßË©≥Á¥∞„Å™„É¨„Ç∑„Éî„ÇíÁîüÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö

{
  "ingredients": [
    { 
      "name": "ÂÖ∑‰ΩìÁöÑ„Å™È£üÊùêÂêç", 
      "amount": "Ê≠£Á¢∫„Å™ÂàÜÈáè", 
      "unit": "Âçò‰ΩçÔºàg/ml/ÂÄã/Êú¨/ÊûöÁ≠âÔºâ",
      "notes": "‰∏ãÂá¶ÁêÜÊñπÊ≥ï„ÇÑ‰ª£ÊõøÊ°à",
      "category": "„É°„Ç§„É≥È£üÊùê/Ë™øÂë≥Êñô/È¶ôËæõÊñô/„Åù„ÅÆ‰ªñ"
    }
  ],
  "steps": [
    { 
      "step_number": 1, 
      "description": "Ë©≥Á¥∞„Å™ÊâãÈ†ÜË™¨ÊòéÔºàÁÅ´Âä†Ê∏õ„ÄÅÊôÇÈñì„ÄÅË¶ã„ÅüÁõÆ„ÅÆÂ§âÂåñ„ÇíÂê´„ÇÄÔºâ", 
      "duration": "ÊâÄË¶ÅÊôÇÈñì",
      "temperature": "ÁÅ´Âä†Ê∏õ„ÉªÊ∏©Â∫¶",
      "tips": "ÊàêÂäü„ÅÆ„Ç≥„ÉÑ„ÉªÊ≥®ÊÑèÁÇπ",
      "tools": ["‰ΩøÁî®„Åô„ÇãË™øÁêÜÂô®ÂÖ∑"]
    }
  ]
}

„ÄêÈáçË¶Å„Å™ÂàÜÊûêË¶Å‰ª∂„Äë:
1. **ÊùêÊñô„ÅÆÂÆåÂÖ®ÊäΩÂá∫**: Ëª¢ÂÜô„Åã„ÇâÂÖ®„Å¶„ÅÆÊùêÊñô„ÇíÊäΩÂá∫ÔºàË™øÂë≥Êñô„ÄÅÈö†„ÅóÂë≥„Åæ„ÅßÂê´„ÇÄÔºâ
2. **ÂàÜÈáè„ÅÆÂÖ∑‰ΩìÂåñ**: „ÄåÂ∞ë„ÄÖ„Äç„ÄåÈÅ©Èáè„Äç‚Üí„ÄåÂ∞è„Åï„Åò1/4„Äç„ÄåÂ§ß„Åï„Åò2„ÄçÁ≠â„Å´Â§âÊèõ
3. **ÊâãÈ†Ü„ÅÆÁ¥∞ÂàÜÂåñ**: ÊúÄ‰Ωé10-15„Çπ„ÉÜ„ÉÉ„Éó„Å´Ë©≥Á¥∞ÂàÜÂâ≤Ôºà‰∏ãÊ∫ñÂÇô„Åã„ÇâÁõõ„Çä‰ªò„Åë„Åæ„ÅßÔºâ
4. **Ë™øÁêÜÊù°‰ª∂„ÅÆÊòéÁ¢∫Âåñ**: ÁÅ´Âäõ„ÄÅÊôÇÈñì„ÄÅÊ∏©Â∫¶„ÇíÂêÑ„Çπ„ÉÜ„ÉÉ„Éó„ÅßÊòéË®ò
5. **Ë¶ñË¶öÁöÑÂ§âÂåñ„ÅÆË®òËø∞**: „Äå„Åç„Å§„Å≠Ëâ≤„Å´„Å™„Çã„Åæ„Åß„Äç„ÄåÊ≥°„ÅåÂá∫„Å¶„Åç„Åü„Çâ„ÄçÁ≠â„ÅÆÁõÆÂÆâ
6. **‰∏¶Ë°å‰ΩúÊ•≠„ÅÆÊßãÈÄ†Âåñ**: ÂêåÊôÇÈÄ≤Ë°å„ÅÆ‰ΩúÊ•≠„ÇÇÈÅ©Âàá„Å´„Çπ„ÉÜ„ÉÉ„ÉóÂåñ
7. **ÂàùÂøÉËÄÖÂØæÂøú**: Âü∫Êú¨ÁöÑ„Å™Ë™øÁêÜÊäÄÊ≥ï„ÇÇË™¨Êòé„Å´Âê´„ÇÅ„Çã

Ëª¢ÂÜôÂÜÖÂÆπ„ÇíÂçòË™û„É¨„Éô„É´„ÅßÁ≤æÊüª„Åó„ÄÅÊñôÁêÜ„Å´Èñ¢„Åô„ÇãÂÖ®„Å¶„ÅÆÊÉÖÂ†±„ÇíË¶ãÈÄÉ„Åï„Åö„Å´ÊäΩÂá∫„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
JSONÂΩ¢Âºè„ÅÆ„É¨„Çπ„Éù„É≥„Çπ„ÅÆ„Åø„ÇíÊèê‰æõ„Åó„ÄÅËøΩÂä†Ë™¨Êòé„ÅØ‰∏çË¶Å„Åß„Åô„ÄÇ
    `.trim();
  }

  /**
   * S3„Åã„Çâ„Éï„É¨„Éº„É†„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
   */
  private async downloadFrameFromS3(frameUrl: string): Promise<Buffer> {
    const response = await fetch(frameUrl);
    if (!response.ok) {
      throw new Error(`Failed to download frame: ${response.statusText}`);
    }
    return Buffer.from(await response.arrayBuffer());
  }

  /**
   * ÂêçÂâç„Å´„Çà„ÇãÈáçË§áÈô§Âéª
   */
  private deduplicateByName(items: any[], nameField: string = 'name'): any[] {
    const seen = new Set<string>();
    return items.filter(item => {
      const name = item[nameField]?.toLowerCase();
      if (name && !seen.has(name)) {
        seen.add(name);
        return true;
      }
      return false;
    });
  }

  /**
   * Èü≥Â£∞Ëª¢ÂÜô„Å®Êò†ÂÉèÂàÜÊûêÁµêÊûú„ÇíÁµ±Âêà„Åó„Å¶Ëß£Êûê„ÇíÂº∑Âåñ
   */
  private integrateAudioVisualAnalysis(
    transcription: string,
    frameAnalysisResult: any,
    recognitionLabels: string[]
  ): any {
    const audioKeywords = this.extractAudioKeywords(transcription);
    const visualIngredients = frameAnalysisResult?.ingredients || [];
    const visualActions = frameAnalysisResult?.actions || [];
    
    const integratedIngredients = this.mergeAudioVisualIngredients(audioKeywords.ingredients, visualIngredients);
    const audioSteps = this.extractStepsFromAudio(transcription);
    const integratedSteps = this.integrateCookingSteps(audioSteps, visualActions);
    
    return {
      ingredients: integratedIngredients,
      actions: visualActions,
      steps: integratedSteps,
      audioKeywords,
      confidence: this.calculateIntegrationConfidence(transcription, frameAnalysisResult)
    };
  }

  /**
   * Èü≥Â£∞„Åã„Çâ„Ç≠„Éº„ÉØ„Éº„Éâ„ÇíÊäΩÂá∫
   */
  private extractAudioKeywords(transcription: string): any {
    const text = transcription.toLowerCase();
    
    const ingredientPatterns = [
      /(?:Áéâ„Å≠„Åé|„Åü„Åæ„Å≠„Åé|onion)/g,
      /(?:„Éà„Éû„Éà|tomato)/g,
      /(?:„Åò„ÇÉ„Åå„ÅÑ„ÇÇ|„Ç∏„É£„Ç¨„Ç§„É¢|potato)/g,
      /(?:‰∫∫ÂèÇ|„Å´„Çì„Åò„Çì|„Éã„É≥„Ç∏„É≥|carrot)/g,
      /(?:Âçµ|„Åü„Åæ„Åî|egg)/g,
      /(?:È∂èËÇâ|„Å®„Çä„Å´„Åè|chicken)/g,
      /(?:ÁâõËÇâ|beef)/g,
      /(?:Ë±öËÇâ|pork)/g,
      /(?:Á±≥|„Åì„ÇÅ|rice)/g,
      /(?:„Éë„É≥|bread)/g,
      /(?:„ÉÅ„Éº„Ç∫|cheese)/g,
      /(?:„Éê„Çø„Éº|butter)/g,
      /(?:Ê≤π|„ÅÇ„Å∂„Çâ|oil)/g,
      /(?:Â°©|„Åó„Åä|salt)/g,
      /(?:ËÉ°Ê§í|„Åì„Åó„Çá„ÅÜ|pepper)/g,
      /(?:ÈÜ§Ê≤π|„Åó„Çá„ÅÜ„ÇÜ)/g,
      /(?:Âë≥Âôå|„Åø„Åù)/g,
      /(?:Á†ÇÁ≥ñ|„Åï„Å®„ÅÜ|sugar)/g
    ];

    const ingredients: string[] = [];
    ingredientPatterns.forEach(pattern => {
      const matches = text.match(pattern);
      if (matches) {
        ingredients.push(...matches);
      }
    });

    const actionPatterns = [
      /(?:Âàá„Çã|„Åç„Çã|Âàª„ÇÄ|„Åç„Åñ„ÇÄ|„Ç´„ÉÉ„Éà)/g,
      /(?:ÁÇí„ÇÅ„Çã|„ÅÑ„Åü„ÇÅ„Çã|„Éï„É©„Ç§)/g,
      /(?:ÁÖÆ„Çã|„Å´„Çã|Ëåπ„Åß„Çã|„ÇÜ„Åß„Çã|„Éú„Ç§„É´)/g,
      /(?:ÁÑº„Åè|„ÇÑ„Åè|„Ç∞„É™„É´|„Éô„Ç§„ÇØ)/g,
      /(?:Ê∑∑„Åú„Çã|„Åæ„Åú„Çã|„Éü„ÉÉ„ÇØ„Çπ)/g,
      /(?:Ëí∏„Åô|„ÇÄ„Åô|„Çπ„ÉÅ„Éº„É†)/g,
      /(?:Êèö„Åí„Çã|„ÅÇ„Åí„Çã)/g,
      /(?:Áõõ„Çä‰ªò„Åë|„ÇÇ„Çä„Å§„Åë|„Éó„É¨„Éº„Éà)/g
    ];

    const actions: string[] = [];
    actionPatterns.forEach(pattern => {
      const matches = text.match(pattern);
      if (matches) {
        actions.push(...matches);
      }
    });

    return {
      ingredients: [...new Set(ingredients)],
      actions: [...new Set(actions)],
      times: [],
      temperatures: []
    };
  }

  /**
   * Èü≥Â£∞„Å®Êò†ÂÉè„ÅÆÈ£üÊùêÊÉÖÂ†±„ÇíÁµ±Âêà
   */
  private mergeAudioVisualIngredients(audioIngredients: string[], visualIngredients: any[]): any[] {
    const merged = [...visualIngredients];
    const visualNames = new Set(visualIngredients.map(v => v.name.toLowerCase()));

    audioIngredients.forEach(audioIngredient => {
      if (!visualNames.has(audioIngredient.toLowerCase())) {
        merged.push({
          name: audioIngredient,
          confidence: 80,
          source: 'audio',
          category: this.categorizeIngredient(audioIngredient.toLowerCase())
        });
      }
    });

    return merged;
  }

  /**
   * Èü≥Â£∞„Åã„ÇâË™øÁêÜÊâãÈ†Ü„ÇíÊäΩÂá∫
   */
  private extractStepsFromAudio(transcription: string): any[] {
    const text = transcription.toLowerCase();
    const sentences = text.split(/[„ÄÇÔºÅÔºü\n]/).filter(s => s.trim().length > 0);
    
    const steps: any[] = [];
    const stepIndicators = [
      '„Åæ„Åö', '„ÅØ„Åò„ÇÅ„Å´', 'first', 'ÊúÄÂàù„Å´',
      'Ê¨°„Å´', '„Å§„Åé„Å´', 'next', 'then',
      'ÊúÄÂæå„Å´', '„Åï„ÅÑ„Åî„Å´', 'finally', 'last',
      '„Åù„ÅÆÂæå', '„ÅÇ„Å®„Åß', 'after'
    ];

    let stepNumber = 1;
    
    sentences.forEach((sentence, index) => {
      const trimmed = sentence.trim();
      
      const hasStepIndicator = stepIndicators.some(indicator => trimmed.includes(indicator));
      const hasAction = /(?:Âàá„Çã|ÁÇí„ÇÅ„Çã|ÁÖÆ„Çã|ÁÑº„Åè|Ê∑∑„Åú„Çã|Âä†„Åà„Çã|Ë™øÁêÜ|ÊñôÁêÜ)/.test(trimmed);
      
      if ((hasStepIndicator || hasAction) && trimmed.length > 5) {
        steps.push({
          stepNumber,
          description: trimmed,
          timestamp: 0,
          confidence: hasStepIndicator ? 85 : 70,
          source: 'audio'
        });
        stepNumber++;
      }
    });

    return steps;
  }

  /**
   * Èü≥Â£∞ÊâãÈ†Ü„Å®Êò†ÂÉè„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÁµ±Âêà
   */
  private integrateCookingSteps(audioSteps: any[], visualActions: any[]): any[] {
    const integratedSteps = [...audioSteps];
    
    visualActions.forEach((action, index) => {
      const relatedAudioStep = audioSteps.find(step => 
        step.description.includes(action.action.toLowerCase()) ||
        this.isRelatedAction(step.description, action.action)
      );
      
      if (!relatedAudioStep) {
        integratedSteps.push({
          stepNumber: audioSteps.length + index + 1,
          description: `${action.action}ÔºàÊò†ÂÉèÂàÜÊûêÔºâ`,
          timestamp: 0,
          confidence: action.confidence,
          source: 'visual',
          visualData: {
            ingredients: action.relatedIngredients?.map((i: any) => i.name) || [],
            tools: action.relatedTools?.map((t: any) => t.name) || []
          }
        });
      }
    });

    return integratedSteps.sort((a, b) => b.confidence - a.confidence);
  }

  /**
   * Èü≥Â£∞Ë®òËø∞„Å®Êò†ÂÉè„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅÆÈñ¢ÈÄ£ÊÄß„ÇíÂà§ÂÆö
   */
  private isRelatedAction(audioDescription: string, visualAction: string): boolean {
    const actionMap: { [key: string]: string[] } = {
      'cutting': ['Âàá„Çã', '„Ç´„ÉÉ„Éà', 'Âàª„ÇÄ'],
      'frying': ['ÁÇí„ÇÅ„Çã', 'ÁÑº„Åè', '„Éï„É©„Ç§'],
      'mixing': ['Ê∑∑„Åú„Çã', '„Éü„ÉÉ„ÇØ„Çπ', '„Åã„ÅçÊ∑∑„Åú'],
      'cooking': ['Ë™øÁêÜ', 'ÊñôÁêÜ', '‰Ωú„Çã'],
      'boiling': ['Ëåπ„Åß„Çã', 'ÁÖÆ„Çã'],
      'steaming': ['Ëí∏„Åô', '„Çπ„ÉÅ„Éº„É†']
    };

    const relatedTerms = actionMap[visualAction.toLowerCase()] || [];
    return relatedTerms.some(term => audioDescription.includes(term));
  }

  /**
   * Áµ±ÂêàÂàÜÊûê„ÅÆ‰ø°È†ºÂ∫¶„ÇíË®àÁÆó
   */
  private calculateIntegrationConfidence(transcription: string, frameAnalysisResult: any): number {
    let confidence = 50;

    if (transcription && transcription.length > 100) {
      confidence += 20;
    }

    if (frameAnalysisResult?.ingredients?.length > 0) {
      confidence += 15;
    }

    if (frameAnalysisResult?.actions?.length > 0) {
      confidence += 15;
    }

    return Math.min(confidence, 100);
  }

  async getJobStatus(jobId: string): Promise<ProcessingJobUpdate | null> {
    const job = await this.prisma.processingJob.findUnique({
      where: { id: jobId },
    });

    if (!job) {
      return null;
    }

    return {
      jobId: job.id,
      status: job.status,
      progressPercent: job.progressPercent,
      errorMessage: job.errorMessage || undefined,
    };
  }

  async getUserJobs(userId: string): Promise<ProcessingJobUpdate[]> {
    const jobs = await this.prisma.processingJob.findMany({
      where: { userId },
      orderBy: { createdAt: 'desc' },
      take: 10,
    });

    return jobs.map(job => ({
      jobId: job.id,
      status: job.status,
      progressPercent: job.progressPercent,
      errorMessage: job.errorMessage || undefined,
    }));
  }

  async cancelJob(jobId: string, userId: string): Promise<boolean> {
    try {
      const job = await this.prisma.processingJob.findFirst({
        where: {
          id: jobId,
          userId,
          status: { in: ['pending', 'transcribing', 'recognizing', 'generating'] },
        },
      });

      if (!job) {
        return false;
      }

      await this.prisma.processingJob.update({
        where: { id: jobId },
        data: {
          status: 'failed',
          errorMessage: 'Cancelled by user',
        },
      });

      return true;
    } catch (error) {
      console.error('Error cancelling job:', error);
      return false;
    }
  }

  async cleanupOldJobs(): Promise<void> {
    try {
      // Delete jobs older than 7 days
      const sevenDaysAgo = new Date();
      sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

      await this.prisma.processingJob.deleteMany({
        where: {
          createdAt: { lt: sevenDaysAgo },
        },
      });

      console.log('Cleaned up old processing jobs');
    } catch (error) {
      console.error('Error cleaning up old jobs:', error);
    }
  }
}